/*
 * STORAGE SERVICE
 * --------------
 * This service handles local data persistence for the application.
 * It's responsible for saving, loading, and managing stories generated by users.
 * 
 * Key functionality:
 * 1. Save stories - Persists generated stories to device storage
 * 2. Load stories - Retrieves previously saved stories
 * 3. Clear stories - Removes all saved stories
 * 
 * Implementation details:
 * - Uses SharedPreferences for simple key-value storage
 * - Serializes Story objects to JSON for storage
 * - Deserializes JSON back to Story objects when loading
 * - Provides error handling for data corruption cases
 * 
 * Usage:
 * - Called from HomeScreen to persist stories between sessions
 * - Used when app starts to load previously generated stories
 * - Called when user wants to clear all stories
 */

// import 'dart:convert';
// import 'package:shared_preferences/shared_preferences.dart';
// import '../models/story.dart';

// class StorageService {
//   static const String _storiesKey = 'generated_stories';

//   // Save stories to local storage
//   Future<void> saveStories(List<Story> stories) async {
//     final prefs = await SharedPreferences.getInstance();
//     final jsonData = Story.storiesToJson(stories);
//     await prefs.setString(_storiesKey, jsonEncode(jsonData));
//   }

//   // Load stories from local storage
//   Future<List<Story>> loadStories() async {
//     try {
//       final prefs = await SharedPreferences.getInstance();
//       final jsonString = prefs.getString(_storiesKey);

//       if (jsonString != null) {
//         final List<dynamic> jsonData = jsonDecode(jsonString);
//         return Story.storiesFromJson(jsonData);
//       }
//     } catch (e) {
//       print('Error loading stories: $e');
//     }

//     return [];
//   }

//   // Clear all stories from local storage
//   Future<void> clearStories() async {
//     final prefs = await SharedPreferences.getInstance();
//     await prefs.remove(_storiesKey);
//   }
// }

// // storage_service.dart
// import 'package:android_app/services/auth/auth_service.dart';
// import 'package:uuid/uuid.dart';
// import '../models/story.dart';
// import 'storage/storage_repository.dart';
// import 'storage/local_storage_repository.dart';
// import 'storage/firebase_storage_repository.dart';

// /// Storage Service for managing story data
// /// This service handles story persistence across the application
// /// It abstracts the underlying implementation (local/Firebase) and provides
// /// a consistent API for story data operations
// class StorageService {
//   static StorageService? _instance;
//   final StoryRepository _repository;
//   final _uuid = const Uuid();

//   /// Private constructor with repository dependency
//   StorageService._({required StoryRepository repository})
//       : _repository = repository;

//   /// Initialize the storage service
//   /// If useFirebase is true, Firebase storage will be used, otherwise local storage
//   static Future<StorageService> init(
//       FirebaseStorageRepository firebaseRepository,
//       {bool useFirebase = true}) async {
//     if (_instance == null) {
//       final repository = useFirebase
//           ? FirebaseStorageRepository()
//           : await LocalStorageRepository.init();

//       _instance = StorageService._(repository: repository);
//     }
//     return _instance!;
//   }

//   /// Get the singleton instance of StorageService
//   static StorageService get instance {
//     if (_instance == null) {
//       throw Exception(
//           'StorageService must be initialized before accessing instance');
//     }
//     return _instance!;
//   }

//   /// Save a list of stories
//   Future<void> saveStories(List<Story> stories) =>
//       _repository.saveStories(stories);

//   /// Load all stories (convenience method that loads stories for current user)
//   Future<List<Story>> loadStories() async {
//     // Get the current user ID from AuthService
//     final currentUser = AuthService.instance.getCurrentUser();
//     if (currentUser == null) {
//       return [];
//     }
//     return loadStoriesForUser(currentUser.id);
//   }

//   /// Load stories for a specific user
//   Future<List<Story>> loadStoriesForUser(String userId) async {
//     final stories = await _repository.loadStoriesForUser(userId);
//     return stories ?? [];
//   }

//   /// Add a new story with automatically generated ID
//   Future<Story> addStory({
//     required String title,
//     required String content,
//     required String userId,
//     bool isFavorite = false,
//   }) async {
//     final story = Story(
//       id: _uuid.v4(),
//       title: title,
//       content: content,
//       userId: userId,
//       createdAt: DateTime.now(),
//       isFavorite: isFavorite,
//     );

//     await _repository.addStory(story);
//     return story;
//   }

//   /// Update an existing story
//   Future<void> updateStory(Story story) => _repository.updateStory(story);

//   /// Toggle favorite status of a story
//   Future<Story> toggleFavorite(Story story) {
//     final updatedStory = story.copyWith(isFavorite: !story.isFavorite);
//     return updateStory(updatedStory).then((_) => updatedStory);
//   }

//   /// Delete a story by ID
//   Future<void> deleteStory(String storyId) => _repository.deleteStory(storyId);

//   /// Clear all stories for a user
//   Future<void> clearUserStories(String userId) =>
//       _repository.clearUserStories(userId);
// }
import 'package:android_app/services/auth/auth_service.dart';
import 'package:uuid/uuid.dart';
import '../models/story.dart';
import 'storage/storage_repository.dart';
import 'storage/local_storage_repository.dart';
import 'storage/firebase_storage_repository.dart';

/// Storage Service for managing story data
/// This service handles story persistence across the application
/// It abstracts the underlying implementation (local/Firebase) and provides
/// a consistent API for story data operations
class StorageService {
  static StorageService? _instance;
  final StoryRepository _repository;
  final _uuid = const Uuid();

  /// Private constructor with repository dependency
  StorageService._({required StoryRepository repository})
      : _repository = repository;

  /// Initialize the storage service
  /// If useFirebase is true, Firebase storage will be used, otherwise local storage
  static Future<StorageService> init({
    required FirebaseStorageRepository firebaseRepository,
    bool useFirebase = true,
  }) async {
    if (_instance == null) {
      final repository = useFirebase
          ? firebaseRepository
          : await LocalStorageRepository.init();

      _instance = StorageService._(repository: repository);
    }
    return _instance!;
  }

  /// Get the singleton instance of StorageService
  static StorageService get instance {
    if (_instance == null) {
      throw Exception(
          'StorageService must be initialized before accessing instance');
    }
    return _instance!;
  }

  /// Save a list of stories
  Future<void> saveStories(List<Story> stories) =>
      _repository.saveStories(stories);

  /// Load all stories (convenience method that loads stories for current user)
  Future<List<Story>> loadStories() async {
    // Get the current user from AuthService
    final currentUser = await AuthService.instance.getCurrentUser();
    if (currentUser == null) {
      return [];
    }
    return loadStoriesForUser(currentUser.uid);
  }

  /// Load stories for a specific user
  Future<List<Story>> loadStoriesForUser(String userId) async {
    final stories = await _repository.loadStoriesForUser(userId);
    return stories ?? [];
  }

  /// Add a new story with automatically generated ID
  Future<Story> addStory({
    required String title,
    required String content,
    required String userId,
    bool isFavorite = false,
  }) async {
    final story = Story(
      id: _uuid.v4(),
      title: title,
      content: content,
      userId: userId,
      createdAt: DateTime.now(),
      isFavorite: isFavorite,
    );

    await _repository.addStory(story);
    return story;
  }

  /// Update an existing story
  Future<void> updateStory(Story story) => _repository.updateStory(story);

  /// Toggle favorite status of a story
  Future<Story> toggleFavorite(Story story) {
    final updatedStory = story.copyWith(isFavorite: !story.isFavorite);
    return updateStory(updatedStory).then((_) => updatedStory);
  }

  /// Delete a story by ID
  Future<void> deleteStory(String storyId) => _repository.deleteStory(storyId);

  /// Clear all stories for a user
  Future<void> clearUserStories(String userId) =>
      _repository.clearUserStories(userId);

  /// Load favorite stories for the current user
  Future<List<Story>> loadFavorites() async {
    final currentUser = await AuthService.instance.getCurrentUser();
    if (currentUser == null) {
      return [];
    }

    // Load all stories for current user
    final allStories = await loadStoriesForUser(currentUser.uid);

    // Filter to return only favorite stories
    return allStories.where((story) => story.isFavorite).toList();
  }

  /// Save favorite stories (convenience method)
  Future<void> saveFavorites(List<Story> favorites) async {
    // This can simply call saveStories if you're storing favorites
    // as part of the stories collection with an isFavorite flag
    return saveStories(favorites);
  }
}
